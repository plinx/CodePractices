=== 41
5 + 10*20/2
// = 105

=== 42
*vec.begin()
// = *(vec.begin())
*vec.begin() + 1
// = *(vec.begin() + 1)

=== 43 
不可接受，优化后的程序可能非原义

=== 44

12 / 3 * 4 + 5 * 15 + 24 % 4 /2
// 4*4 + 75 + 0/2 = 91

=== 45
(a) -30 * 3 + 21 / 5 = -86
(b) -30 + 3 * 21 / 5 = -18
(c) 30 / 3 * 21 % 5 = 0
(d) -30 / 3 * 21 % 4 = -2

=== 46
if (val % 2) 	// odd
	...
else 			// even
	...
	
=== 47
-1/0
0/-1
-(1/0)

=== 48
(1) &&
先左值，若左值为 1，再求右值
(2) ||
先左值，若左值为 0，再求右值
(3) ==
先左右，再右值

=== 49
const char *cp = "Hello World.";
if (cp && *cp)	
// 指针不为空 且 指针指向地址内容不为空

=== 410
while (cin >> test && test != 42);

=== 411
if (a > b && b > c && c > d) {
	...
}

=== 412
i != j < k;
// i 不等与 j 小于 k 的判断结果(0 or 1)

=== 413
int i;
double d;
(a) d = i = 3.5;	// d = 3.0, i = 3
(b) i = d = 3.5; 	// d = 3.5, i = 3

=== 414
if (42 = i)	// err：赋值错误
if (i = 42) // 若不存在 i, 赋值错误

=== 415
double dval;
int ival;
int *pi;
dval = ival = pi = 0; 	// err: pi is int *
dval = ival = *pi = 0;

=== 416
(a) if (p = getPtr() != 0)
if ((p = getPtr()) != 0)
(b) if (i = 1024)
if (i == 1024)

=== 417 
前置运算将数值作为左值返回，
后置运算将数值拷贝作为右值返回

=== 418
无法输出第一个元素

=== 419
(a) ptr != 0 && *ptr++
ptr 不为空 且 ptr 的下一个位置值不为0
(b) ival++ && ival
ival + 1 值不为空
(c) vec[ival++] <= vec[ival]
vec[ival] 的值 小于等于 vec[ival + 1] 的值

=== 420
(a) *iter++;	// = *(iter++)
(b) (*iter)++;	
(c) *iter.empty(); // err: =*(iter.empty())
(d) iter->empty();
(e) ++*iter;
(f) iter++->empty();	// (iter++)->empty()

=== 421
for (auto &v : vec) {
	if (v % 2) {
		v = v*v;
	}
}
